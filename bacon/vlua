-- aim configuration
local aim_config = _G.JALON_AIMCONFIG or {
    Enabled = true,
    KeyActivation = Enum.KeyCode.LeftShift,
    GuiToggleKey = Enum.KeyCode.LeftAlt,

    FOV = 150,
    TeamCheck = true,
    DistanceCheck = true,
    VisibleCheck = true,

    Smoothness = 0.975,
    Prediction = {
        Enabled = false,
        Value = 0.185
    },
    AimTarget = "Head",
    FOVVisibility = "Always Show FOV" -- Added FOV visibility option
}
_G.JALON_AIMCONFIG = _G.JALON_AIMCONFIG or aim_config

-- services
local input_service = game:GetService("UserInputService")
local players = game:GetService("Players")
local run_service = game:GetService("RunService")
local gui_service = game:GetService("StarterGui")
local teleport_service = game:GetService("TeleportService")

-- objects
local camera = workspace.CurrentCamera
local player = players.LocalPlayer
local fovCircle, targetBox = Drawing.new("Circle"), Drawing.new("Square")

-- variables
local current_nearest_plr
local dragging = false
local dragInput
local dragStart
local startPos
local espEnabled = false
local guiVisible = true
local selectingKeybind = false

-- functions
local function is_player_valid(plrArg)
    local plrChar = plrArg.Character
    local plrHumanoid, target_part = (plrChar and plrChar:FindFirstChildWhichIsA("Humanoid")), (plrChar and plrChar:FindFirstChild(aim_config.AimTarget))
    return plrArg ~= player and (plrChar and (plrHumanoid and plrHumanoid.Health ~= 0)) and not plrArg.Character:FindFirstChildWhichIsA("ForceField") and (if aim_config.TeamCheck then (plrArg.Neutral or plrArg.TeamColor ~= player.TeamColor) else true), target_part
end

local function get_rootpart(plr)
    return (if plr.Character then plr.Character:FindFirstChild(aim_config.AimTarget) else nil)
end

local function in_line_of_sight(origin_pos, ...)
    return #camera:GetPartsObscuringTarget({origin_pos}, {camera, player.Character, ...}) == 0
end

local function get_vel_prediction(velocity)
    return Vector3.new(velocity.X, math.clamp((velocity.Y * 0.5), -5, 10), velocity.Z)
end

local function get_camera_prediction(predicting_part)
    return predicting_part.CFrame + get_vel_prediction(predicting_part.Velocity) * (aim_config.Prediction.Value)
end

-- gets nearest player relative to cursor
local function get_nearest_player()
    local nearest_plr_data = {aimPart = nil, cursor_dist = math.huge, char_dist = math.huge}

    for _, plr in players:GetPlayers() do
        local passed, target_part = is_player_valid(plr)
        if not (passed and target_part) then continue end
        local screen_pos, on_screen = camera:WorldToViewportPoint(target_part.Position)
        local fov_dist = (input_service:GetMouseLocation() - Vector2.new(screen_pos.X, screen_pos.Y)).Magnitude
        local char_dist = (get_rootpart(player).Position - target_part.Position).Magnitude

        if (not aim_config.VisibleCheck or (on_screen and in_line_of_sight(camera.CFrame, plr.Character))) then
            if ((fov_dist <= aim_config.FOV) and (fov_dist < nearest_plr_data.cursor_dist)) and (not aim_config.DistanceCheck or (char_dist < nearest_plr_data.char_dist)) then
                nearest_plr_data.aimPart = target_part
                nearest_plr_data.cursor_dist = fov_dist
                nearest_plr_data.char_dist = char_dist
            end
        end
    end
    return (if nearest_plr_data.aimPart then nearest_plr_data else nil)
end

-- ESP functionality
local espBoxes = {}

local function toggle_esp(state)
    espEnabled = state
    for _, box in pairs(espBoxes) do
        box.Visible = state
    end
end

local function update_esp()
    for _, plr in players:GetPlayers() do
        if plr ~= player then
            local plrChar = plr.Character
            if plrChar and plrChar:FindFirstChild("HumanoidRootPart") then
                local rootPart = plrChar:FindFirstChild("HumanoidRootPart")
                local screenPos, onScreen = camera:WorldToViewportPoint(rootPart.Position)

                if not espBoxes[plr] then
                    local box = Drawing.new("Square")
                    box.Color = Color3.fromRGB(255, 0, 0)
                    box.Thickness = 2
                    box.Filled = false
                    espBoxes[plr] = box
                end

                local box = espBoxes[plr]
                box.Visible = espEnabled and onScreen and (not aim_config.TeamCheck or plr.TeamColor ~= player.TeamColor)
                if box.Visible then
                    box.Size = Vector2.new(100, 50) -- Adjust the size as needed
                    box.Position = Vector2.new(screenPos.X - 50, screenPos.Y - 25) -- Adjust the position as needed
                end
            end
        end
    end
end

-- Create GUI
local screenGui = Instance.new("ScreenGui")
local aimFrame = Instance.new("Frame")
local aimHeadButton = Instance.new("TextButton")
local aimTorsoButton = Instance.new("TextButton")
local teamCheckButton = Instance.new("TextButton")
local espButton = Instance.new("TextButton")
local rejoinButton = Instance.new("TextButton")
local closeButton = Instance.new("TextButton")
local madeByLabel = Instance.new("TextLabel")
local keybindButton = Instance.new("TextButton")
local fovTextBox = Instance.new("TextBox")
local smoothnessTextBox = Instance.new("TextBox")
local fovVisibilityDropdown = Instance.new("TextButton")
local dropdownMenu = Instance.new("Frame")
local dropdownItems = {"Always Show FOV", "Only Show FOV While Aimbot Enabled", "Invisible"}
local gradient = Instance.new("UIGradient")
local corner = Instance.new("UICorner")

screenGui.Parent = player:WaitForChild("PlayerGui")
screenGui.Name = "AimBotGui"

aimFrame.Parent = screenGui
aimFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
aimFrame.Size = UDim2.new(0, 160, 0, 500) -- Adjusted height to fit new dropdown menu
aimFrame.Position = UDim2.new(0, 10, 0, 10)
aimFrame.Active = true
aimFrame.Draggable = true

corner.CornerRadius = UDim.new(0, 10)
corner.Parent = aimFrame

gradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(50, 50, 50)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(75, 75, 75))
}
gradient.Parent = aimFrame

local function styleButton(button)
    button.BackgroundColor3 = Color3.fromRGB(75, 75, 75)
    button.Size = UDim2.new(0, 140, 0, 30)
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.Font = Enum.Font.SourceSansBold
    button.TextSize = 18
    corner:Clone().Parent = button
end

aimHeadButton.Parent = aimFrame
aimHeadButton.Position = UDim2.new(0, 10, 0, 10)
aimHeadButton.Text = "Aim Head"
aimHeadButton.MouseButton1Click:Connect(function()
    aim_config.AimTarget = "Head"
end)
styleButton(aimHeadButton)

aimTorsoButton.Parent = aimFrame
aimTorsoButton.Position = UDim2.new(0, 10, 0, 50)
aimTorsoButton.Text = "Aim Torso"
aimTorsoButton.MouseButton1Click:Connect(function()
    aim_config.AimTarget = "HumanoidRootPart"
end)
styleButton(aimTorsoButton)

teamCheckButton.Parent = aimFrame
teamCheckButton.Position = UDim2.new(0, 10, 0, 90)
teamCheckButton.Text = "Team Check: On"
teamCheckButton.MouseButton1Click:Connect(function()
    aim_config.TeamCheck = not aim_config.TeamCheck
    teamCheckButton.Text = "Team Check: " .. (aim_config.TeamCheck and "On" or "Off")
end)
styleButton(teamCheckButton)

espButton.Parent = aimFrame
espButton.Position = UDim2.new(0, 10, 0, 130)
espButton.Text = "ESP: Off"
espButton.MouseButton1Click:Connect(function()
    espEnabled = not espEnabled
    toggle_esp(espEnabled)
    espButton.Text = "ESP: " .. (espEnabled and "On" or "Off")
end)
styleButton(espButton)

rejoinButton.Parent = aimFrame
rejoinButton.Position = UDim2.new(0, 10, 0, 170)
rejoinButton.Text = "Rejoin"
rejoinButton.MouseButton1Click:Connect(function()
    teleport_service:Teleport(game.PlaceId)
end)
styleButton(rejoinButton)

closeButton.Parent = aimFrame
closeButton.Position = UDim2.new(0, 10, 0, 210)
closeButton.Text = "Close GUI"
closeButton.MouseButton1Click:Connect(function()
    aimFrame.Visible = false
end)
styleButton(closeButton)

madeByLabel.Parent = aimFrame
madeByLabel.Position = UDim2.new(0, 10, 0, 250)
madeByLabel.Size = UDim2.new(0, 140, 0, 30)
madeByLabel.Text = "Made by Bacon"
madeByLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
madeByLabel.BackgroundTransparency = 1
madeByLabel.Font = Enum.Font.SourceSansBold
madeByLabel.TextSize = 18

keybindButton.Parent = aimFrame
keybindButton.Position = UDim2.new(0, 10, 0, 290)
keybindButton.Text = "Keybind: " .. aim_config.KeyActivation.Name
keybindButton.MouseButton1Click:Connect(function()
    selectingKeybind = true
    keybindButton.Text = "Press any key..."
end)
styleButton(keybindButton)

fovTextBox.Parent = aimFrame
fovTextBox.Position = UDim2.new(0, 10, 0, 330)
fovTextBox.Size = UDim2.new(0, 140, 0, 30)
fovTextBox.PlaceholderText = "FOV: " .. aim_config.FOV
fovTextBox.Text = ""
fovTextBox.Font = Enum.Font.SourceSansBold
fovTextBox.TextSize = 18
fovTextBox.TextColor3 = Color3.fromRGB(255, 255, 255)
fovTextBox.BackgroundColor3 = Color3.fromRGB(75, 75, 75)
corner:Clone().Parent = fovTextBox

fovTextBox.FocusLost:Connect(function(enterPressed)
    if enterPressed then
        local newFOV = tonumber(fovTextBox.Text)
        if newFOV then
            aim_config.FOV = newFOV
            fovTextBox.PlaceholderText = "FOV: " .. aim_config.FOV
            fovTextBox.Text = ""
        end
    end
end)

smoothnessTextBox.Parent = aimFrame
smoothnessTextBox.Position = UDim2.new(0, 10, 0, 370)
smoothnessTextBox.Size = UDim2.new(0, 140, 0, 30)
smoothnessTextBox.PlaceholderText = "Smoothness: " .. aim_config.Smoothness
smoothnessTextBox.Text = ""
smoothnessTextBox.Font = Enum.Font.SourceSansBold
smoothnessTextBox.TextSize = 18
smoothnessTextBox.TextColor3 = Color3.fromRGB(255, 255, 255)
smoothnessTextBox.BackgroundColor3 = Color3.fromRGB(75, 75, 75)
corner:Clone().Parent = smoothnessTextBox

smoothnessTextBox.FocusLost:Connect(function(enterPressed)
    if enterPressed then
        local newSmoothness = tonumber(smoothnessTextBox.Text)
        if newSmoothness then
            aim_config.Smoothness = newSmoothness
            smoothnessTextBox.PlaceholderText = "Smoothness: " .. aim_config.Smoothness
            smoothnessTextBox.Text = ""
        end
    end
end)

fovVisibilityDropdown.Parent = aimFrame
fovVisibilityDropdown.Position = UDim2.new(0, 10, 0, 410)
fovVisibilityDropdown.Text = "FOV Visibility: " .. aim_config.FOVVisibility
fovVisibilityDropdown.MouseButton1Click:Connect(function()
    dropdownMenu.Visible = not dropdownMenu.Visible
end)
styleButton(fovVisibilityDropdown)

dropdownMenu.Parent = aimFrame
dropdownMenu.Position = UDim2.new(0, 10, 0, 450)
dropdownMenu.Size = UDim2.new(0, 140, 0, 90)
dropdownMenu.Visible = false
dropdownMenu.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
corner:Clone().Parent = dropdownMenu

for i, item in ipairs(dropdownItems) do
    local dropdownItem = Instance.new("TextButton")
    dropdownItem.Parent = dropdownMenu
    dropdownItem.Position = UDim2.new(0, 0, 0, (i - 1) * 30)
    dropdownItem.Size = UDim2.new(0, 140, 0, 30)
    dropdownItem.Text = item
    dropdownItem.TextColor3 = Color3.fromRGB(255, 255, 255)
    dropdownItem.BackgroundColor3 = Color3.fromRGB(75, 75, 75)
    dropdownItem.Font = Enum.Font.SourceSansBold
    dropdownItem.TextSize = 18
    corner:Clone().Parent = dropdownItem

    dropdownItem.MouseButton1Click:Connect(function()
        aim_config.FOVVisibility = item
        fovVisibilityDropdown.Text = "FOV Visibility: " .. item
        dropdownMenu.Visible = false
    end)
end

input_service.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if input.UserInputType == Enum.UserInputType.Keyboard then
        if selectingKeybind then
            aim_config.KeyActivation = input.KeyCode
            keybindButton.Text = "Keybind: " .. input.KeyCode.Name
            selectingKeybind = false
        elseif input.KeyCode == aim_config.GuiToggleKey then
            guiVisible = not guiVisible
            aimFrame.Visible = guiVisible
        elseif input.KeyCode == aim_config.KeyActivation then
            aim_config.Enabled = true
        end
    end
end)

input_service.InputEnded:Connect(function(input, gpe)
    if gpe then return end
    if input.UserInputType == Enum.UserInputType.Keyboard then
        if input.KeyCode == aim_config.KeyActivation then
            aim_config.Enabled = false
        end
    end
end)

-- updates
run_service.RenderStepped:Connect(function()
    local fovVisible = false
    if aim_config.FOVVisibility == "Always Show FOV" then
        fovVisible = true
    elseif aim_config.FOVVisibility == "Only Show FOV While Aimbot Enabled" and aim_config.Enabled then
        fovVisible = true
    end

    fovCircle.Visible = fovVisible
    fovCircle.Position = input_service:GetMouseLocation()
    fovCircle.Thickness = 1.5
    fovCircle.NumSides = 18
    fovCircle.Radius = aim_config.FOV
    fovCircle.Color = Color3.fromRGB(255, 255, 255)
    fovCircle.Filled = false

    update_esp()

    if aim_config.Enabled then
        local nearest_plr_data = get_nearest_player()
        if nearest_plr_data then
            current_nearest_plr = nearest_plr_data.aimPart
        else
            current_nearest_plr = nil
        end
    else
        current_nearest_plr = nil
    end

    if current_nearest_plr then
        local predicted_camera = (if aim_config.Prediction.Enabled then get_camera_prediction(current_nearest_plr) else current_nearest_plr.CFrame)
        local current_camera = camera.CFrame.Position
        camera.CFrame = CFrame.lookAt(current_camera, predicted_camera.Position:Lerp(current_camera, aim_config.Smoothness))
    end
end)

-- Dragging functionality
local function updateInput(input)
    local delta = input.Position - dragStart
    aimFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

aimFrame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = aimFrame.Position

        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

aimFrame.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

input_service.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        updateInput(input)
    end
end)

-- initial ESP state
toggle_esp(espEnabled)
